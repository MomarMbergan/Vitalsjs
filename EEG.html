<!DOCTYPE html>
<html>
<head>
  <title>EEG + rPPG Dashboard (Fusion Methods)</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: Arial;
      text-align: center;
      overflow: hidden;
    }

    video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: 0;
    }

    canvas {
      width: 90%;
      height: 200px;
      background: rgba(0,0,0,0.05); /* 95% transparent */
      margin-top: 10px;
      border-radius: 10px;
      z-index: 1;
      position: relative;
    }

    #foreheadBox {
      position: absolute;
      border: 2px solid red;
      pointer-events: none;
      z-index: 2;
    }

    #fusionOutput {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 15px;
      color: white;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      z-index: 3;
      text-align: left;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>

<video id="camera" autoplay muted playsinline></video>
<div id="foreheadBox"></div>

<canvas id="rppgChart"></canvas>
<canvas id="eegChart"></canvas>

<div id="fusionOutput">
  <div id="freqFusion">1. Frequency-Domain Fusion: 0 Hz</div>
  <div id="peakFusion">2. Peak-Based Fusion: 0 Hz</div>
  <div id="coherenceFusion">3. Cross-Spectral Coherence: 0</div>
</div>

<script>
/* -------------------------------
   CAMERA FULL SCREEN + rPPG
-------------------------------- */
const video = document.getElementById('camera');

navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }})
.then(stream => video.srcObject = stream);

let rData = [];
let eegData = [];

const rppgCtx = document.getElementById('rppgChart').getContext('2d');
const rppgChart = new Chart(rppgCtx, {
  type: 'line',
  data: {
    labels: Array(300).fill(""),
    datasets: [{
      label: "rPPG Heart Signal",
      data: Array(300).fill(0),
      borderColor: "red",
      borderWidth: 2,
      pointRadius: 0
    }]
  },
  options: {
    animation: false,
    scales: { y: { min: -20, max: 20 } }
  }
});

const eegCtx = document.getElementById('eegChart').getContext('2d');
const eegChart = new Chart(eegCtx, {
  type: 'line',
  data: {
    labels: Array(300).fill(""),
    datasets: [{
      label: "EEG Signal",
      data: Array(300).fill(0),
      borderColor: "cyan",
      borderWidth: 2,
      pointRadius: 0
    }]
  },
  options: {
    animation: false,
    scales: { y: { min: -100, max: 100 } }
  }
});

// rPPG frame reader
setInterval(() => {
  if (!video.videoWidth) return;

  const w = video.videoWidth;
  const h = video.videoHeight;

  const foreheadW = w * 0.30;
  const foreheadH = h * 0.10;
  const foreheadX = w * 0.35;
  const foreheadY = h * 0.15;

  const box = document.getElementById("foreheadBox");
  const rect = video.getBoundingClientRect();
  const scaleX = rect.width / w;
  const scaleY = rect.height / h;
  box.style.left = (rect.left + foreheadX * scaleX) + "px";
  box.style.top  = (rect.top + foreheadY * scaleY) + "px";
  box.style.width  = foreheadW * scaleX + "px";
  box.style.height = foreheadH * scaleY + "px";

  const temp = document.createElement("canvas");
  temp.width = foreheadW;
  temp.height = foreheadH;
  const tctx = temp.getContext("2d");
  tctx.drawImage(video, foreheadX, foreheadY, foreheadW, foreheadH, 0, 0, foreheadW, foreheadH);

  const frame = tctx.getImageData(0, 0, foreheadW, foreheadH);
  let sum = 0, count = 0;

  for (let i = 0; i < frame.data.length; i += 4) {
    sum += frame.data[i]; // Red channel average
    count++;
  }

  const val = (sum / count) - 128;
  rData.push(val);
  if (rData.length > 300) rData.shift();

  rppgChart.data.datasets[0].data = rData;
  rppgChart.update();
}, 50);

// EEG mock signal
setInterval(() => {
  const newVal = Math.sin(Date.now() / 120) * 50;
  eegData.push(newVal);
  if (eegData.length > 300) eegData.shift();
  eegChart.data.datasets[0].data = eegData;
  eegChart.update();
}, 50);

/* -------------------------------
   Fusion Methods
-------------------------------- */

// Simple FFT helper (naive DFT for demo)
function fftMagnitude(signal) {
  const N = signal.length;
  let mags = [];
  for (let k = 0; k < N/2; k++) {
    let re = 0, im = 0;
    for (let n = 0; n < N; n++) {
      const angle = (2 * Math.PI * k * n) / N;
      re += signal[n] * Math.cos(angle);
      im -= signal[n] * Math.sin(angle);
    }
    mags.push(Math.sqrt(re*re + im*im));
  }
  return mags;
}

setInterval(() => {
  if (rData.length < 100 || eegData.length < 100) return;

  // 1. Frequency-Domain Fusion
  const rFFT = fftMagnitude(rData);
  const eFFT = fftMagnitude(eegData);
  const fusedFFT = rFFT.map((val, i) => val + (eFFT[i] || 0));
  const freqFusion = fusedFFT.indexOf(Math.max(...fusedFFT));
  document.getElementById("freqFusion").textContent = "1. Frequency-Domain Fusion: " + freqFusion + " Hz";

  // 2. Peak-Based Fusion
  const rPeak = rFFT.indexOf(Math.max(...rFFT));
  const ePeak = eFFT.indexOf(Math.max(...eFFT));
  const peakFusion = 0.5 * rPeak + 0.5 * ePeak;
  document.getElementById("peakFusion").textContent = "2. Peak-Based Fusion: " + peakFusion.toFixed(2) + " Hz";

  // 3. Cross-Spectral Coherence (simplified)
  let cross = 0, rPow = 0, ePow = 0;
  for (let i = 0; i < rFFT.length; i++) {
    cross += rFFT[i] * (eFFT[i] || 0);
    rPow += rFFT[i] * rFFT[i];
    ePow += (eFFT[i] || 0) * (eFFT[i] || 0);
  }
  const coherence = (cross*cross) / (rPow * ePow + 1e-9);
  document.getElementById("coherenceFusion").textContent = "3. Cross-Spectral Coherence: " + coherence.toFixed(3);
}, 1000);

</script>

</body>
</html>
