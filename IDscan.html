<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dual Camera Thermal Dashboard — Combined</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- Pico face/eye detector (keep your file paths) -->
  <script src="/js/pico.js"></script>
  <script src="/js/iploc.js"></script>

  <!-- MathJax for LaTeX -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    /* Font preference: Astro, fallback to futuristic system fonts */
    @font-face {
      font-family: 'Astro';
      /* If you have an Astro webfont URL, put it here in src. Leave commented otherwise. */
      /* src: url('/fonts/Astro.woff2') format('woff2'); */
      font-weight: normal; font-style: normal; font-display:swap;
    }

    body { margin:0; background:black; font-family: 'Astro', "Orbitron", "Exo 2", Arial, sans-serif; color:#00e5ff; }
    .container { display:flex; flex-direction:row; width:100vw; height:100vh; }
    .screen { position:relative; flex:1; overflow:hidden; }
    video, canvas.overlay { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; }
    .cameraControls { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.6); padding:10px; border-radius:8px; color:#00e5ff; z-index:30; }
    .cameraControls select, .cameraControls input { display:block; margin:6px 0; width:180px; padding:6px; border-radius:6px; border:none; background:rgba(255,255,255,0.06); color:#00e5ff; }
    .statusBlock { position:absolute; top:120px; left:10px; background:rgba(0,0,0,0.6); padding:8px 12px; border-radius:6px; font-size:0.9rem; color:#ff4081; z-index:25; }
    .analyzing { position:absolute; top:12px; left:50%; transform:translateX(-50%); font-size:1.2rem; color:#39ff14; text-shadow:0 0 8px #39ff14,0 0 14px #39ff14; z-index:40; }
    .hud { position:absolute; top:160px; left:10px; background:rgba(0,0,0,0.5); padding:10px 14px; border-radius:8px; color:#00e5ff; font-size:1rem; line-height:1.6; z-index:20;
          text-shadow:0 0 8px #00e5ff,0 0 14px #00e5ff; }
    .eq { margin-top:6px; color:#00b8ff; font-size:0.86rem; }
    .eq .math { text-shadow:0 0 8px #00b8ff,0 0 18px #00b8ff; display:block; padding-top:6px; }
    .charts { position:absolute; bottom:0; left:0; width:100%; height:32%; display:flex; gap:20px; padding:12px 20px; background:rgba(0,0,0,0.4); z-index:15; }
    .chartBlock { flex:1; display:flex; flex-direction:column; }
    .chartLabel { color:#00e5ff; margin-bottom:6px; text-shadow:0 0 8px #00e5ff,0 0 14px #00e5ff; }
    .chartCanvas { width:100%; height:100%; background:transparent; }
    @media(max-width:768px){ .container{flex-direction:column;} .screen{height:50%;} }
  </style>
</head>
<body>
  <div class="container">
    <!-- FRONT CAMERA -->
    <div class="screen">
      <div class="analyzing">Analyzing</div>
      <div class="cameraControls">
        <label>Front Camera Source</label>
        <select id="frontSource" onchange="switchFrontCamera(this.value)">
          <option value="device">Device Camera</option>
          <option value="wifi">Wi-Fi Camera</option>
        </select>
        <input id="frontIp" type="text" placeholder="Wi-Fi IP"/>
        <input id="frontMac" type="text" placeholder="MAC Address"/>
      </div>
      <div id="frontStatus" class="statusBlock">Status: Not Connected</div>
      <video id="frontCam" autoplay playsinline muted></video>
      <canvas id="frontOverlay" class="overlay"></canvas>
      <div class="hud">
        PPG: <span id="hrFront">--</span> bpm<br>
        SpO₂: <span id="spo2Front">--</span> %<br>
        <div id="eqFront" class="eq">
          <!-- MathJax equations will be injected here -->
        </div>
      </div>
      <div class="charts">
        <div class="chartBlock"><div class="chartLabel">Iris-Retina Signal</div><canvas id="ppgFront" class="chartCanvas"></canvas></div>
        <div class="chartBlock"><div class="chartLabel">SpO₂ Signal</div><canvas id="spo2FrontChart" class="chartCanvas"></canvas></div>
      </div>
    </div>

    <!-- REAR CAMERA -->
    <div class="screen">
      <div class="analyzing">Analyzing</div>
      <div class="cameraControls">
        <label>Rear Camera Source</label>
        <select id="rearSource" onchange="switchRearCamera(this.value)">
          <option value="device">Device Camera</option>
          <option value="wifi">Wi-Fi Camera</option>
        </select>
        <input id="rearIp" type="text" placeholder="Wi-Fi IP"/>
        <input id="rearMac" type="text" placeholder="MAC Address"/>
      </div>
      <div id="rearStatus" class="statusBlock">Status: Not Connected</div>
      <video id="rearCam" autoplay playsinline muted></video>
      <canvas id="rearOverlay" class="overlay"></canvas>
      <div class="hud">
        PPG: <span id="hrRear">--</span> bpm<br>
        SpO₂: <span id="spo2Rear">--</span> %<br>
        <div id="eqRear" class="eq"></div>
      </div>
      <div class="charts">
        <div class="chartBlock"><div class="chartLabel">Iris-Retina Signal</div><canvas id="ppgRear" class="chartCanvas"></canvas></div>
        <div class="chartBlock"><div class="chartLabel">SpO₂ Signal</div><canvas id="spo2RearChart" class="chartCanvas"></canvas></div>
      </div>
    </div>
  </div>

<script>
/* ---------- Utility: Status ---------- */
function setStatus(elId,text,ok){
  const el=document.getElementById(elId);
  el.textContent = "Status: " + text;
  el.style.color = ok ? "#00e676" : "#ff4081";
}

/* ---------- Camera switching (unchanged logic) ---------- */
async function switchFrontCamera(source){
  const video=document.getElementById("frontCam");
  if(source==="device"){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"},audio:false});
      video.srcObject=stream;
      setStatus("frontStatus","✅ Connected to Device Camera",true);
    } catch(e){
      setStatus("frontStatus","❌ Device Camera Access Denied",false);
    }
  } else {
    const ip=document.getElementById("frontIp").value.trim();
    const mac=document.getElementById("frontMac").value.trim();
    if(!ip) return setStatus("frontStatus","❌ Missing Wi-Fi IP",false);
    video.srcObject=null;
    video.src=`http://${ip}/live.mp4?mac=${encodeURIComponent(mac)}`;
    video.play().then(()=>setStatus("frontStatus","✅ Connected to Wi-Fi Camera",true))
               .catch(()=>setStatus("frontStatus","❌ Wi-Fi Camera Unreachable",false));
  }
}

async function switchRearCamera(source){
  const video=document.getElementById("rearCam");
  if(source==="device"){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"},audio:false});
      video.srcObject=stream;
      setStatus("rearStatus","✅ Connected to Device Camera",true);
    } catch(e){
      setStatus("rearStatus","❌ Device Camera Access Denied",false);
    }
  } else {
    const ip=document.getElementById("rearIp").value.trim();
    const mac=document.getElementById("rearMac").value.trim();
    if(!ip) return setStatus("rearStatus","❌ Missing Wi-Fi IP",false);
    video.srcObject=null;
    video.src=`http://${ip}/live.mp4?mac=${encodeURIComponent(mac)}`;
    video.play().then(()=>setStatus("rearStatus","✅ Connected to Wi-Fi Camera",true))
               .catch(()=>setStatus("rearStatus","❌ Wi-Fi Camera Unreachable",false));
  }
}

/* ---------- Charts setup ---------- */
let charts = {};
function makeGradient(ctx){
  const g = ctx.createLinearGradient(0,0,0,ctx.canvas.height);
  g.addColorStop(0, 'rgba(0, 200, 255, 0.9)');
  g.addColorStop(1, 'rgba(0, 80, 140, 0.1)');
  return g;
}
function createChart(canvasId, label){
  const ctx = document.getElementById(canvasId).getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label,
        data: [],
        borderColor: 'rgba(0,200,255,0.95)',
        backgroundColor: makeGradient(ctx),
        fill: true,
        borderWidth: 2,
        tension: 0.25,
        pointRadius: 0
      }]
    },
    options: {
      animation: false,
      responsive: true,
      maintainAspectRatio: false,
      scales: { x: { display:false }, y: { display:true } },
      plugins: { legend: { display:false } }
    }
  });
}

function initCharts(){
  charts.ppgFront = createChart('ppgFront','Iris-Retina PPG');
  charts.spo2Front = createChart('spo2FrontChart','SpO₂ Front');
  charts.ppgRear = createChart('ppgRear','Iris-Retina PPG');
  charts.spo2Rear = createChart('spo2RearChart','SpO₂ Rear');
}

/* ---------- MathJax equations for HUD (glowing blue) ---------- */
const frontEquations = [
  `\\\\(\\gamma = \\dfrac{L_{signal}}{L_{noise}}\\\\)`,
  `\\\\(P = \\dfrac{TP}{TP + FP}\\\\)`, // detection precision
  `\\\\(z = \\dfrac{f\\,D}{D - f}\\\\)`, // thin lens/geometric depth example
  `\\\\(I = \\dfrac{I_0}{r^2}\\\\)`, // inverse square law
  `\\\\(\\text{Live PPG: } f_{ppg}(t) = \\mathcal{F}\\{\\text{rPPG}(t)\\} \\\\)`,
];

const rearEquations = frontEquations.slice(); // same set for rear

function renderEquations(){
  const eqFront = document.getElementById('eqFront');
  const eqRear = document.getElementById('eqRear');
  eqFront.innerHTML = frontEquations.map(s => `<span class="math">\\(${s.replace(/^\\\\\\(|\\\\\\)$/g,'')}\\)</span>`).join('');
  eqRear.innerHTML = rearEquations.map(s => `<span class="math">\\(${s.replace(/^\\\\\\(|\\\\\\)$/g,'')}\\)</span>`).join('');
  // Request MathJax to typeset the newly injected math
  if(window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise();
}

/* ---------- rPPG-like demo extraction (averaging green channel) ---------- */
/* This is a simple, robust demo of PPG extraction: capture small ROI, average green channel. */
function createFrameGrabber(videoElement, overlayCanvasId){
  const video = videoElement;
  const overlay = document.getElementById(overlayCanvasId);
  const ctx = overlay.getContext('2d');
  const scratch = document.createElement('canvas');
  const sctx = scratch.getContext('2d');

  // keep overlay size synced
  function resize(){
    overlay.width = overlay.clientWidth;
    overlay.height = overlay.clientHeight;
    scratch.width = overlay.width;
    scratch.height = overlay.height;
  }
  window.addEventListener('resize', resize);
  resize();

  let samples = []; // raw brightness samples (for PPG)
  const maxSamples = 300;

  function processFrame(){
    if(video.readyState < 2) { requestAnimationFrame(processFrame); return; }
    // draw current frame to scratch
    sctx.drawImage(video, 0, 0, scratch.width, scratch.height);

    // Optionally run pico.js face/eye detection (if available)
    try{
      if(window.pico && window.iploc){
        // Basic usage: run detector (this assumes you loaded the cascade into pico.js beforehand)
        // If you don't have cascades loaded, these calls will silently fail (hence try/catch)
        // Example (pseudo): pico.runCascade(scratchImage, cascade, threshold)
        // We'll just draw a placeholder: detect center face-ish box.
        const octx = ctx;
        octx.clearRect(0,0,overlay.width, overlay.height);
        // If pico provided detections, draw them; fallback draw center box
        const w = overlay.width, h = overlay.height;
        octx.strokeStyle = 'rgba(0,200,255,0.9)';
        octx.lineWidth = 2;
        octx.strokeRect(w*0.35, h*0.18, w*0.3, h*0.35);
      } else {
        // draw a subtle blue overlay placeholder
        ctx.clearRect(0,0,overlay.width, overlay.height);
        ctx.strokeStyle = 'rgba(0,200,255,0.22)';
        ctx.lineWidth = 2;
        ctx.strokeRect(overlay.width*0.36, overlay.height*0.2, overlay.width*0.28, overlay.height*0.32);
      }
    } catch(e){
      // if script errors, clear overlay and continue
      ctx.clearRect(0,0,overlay.width, overlay.height);
    }

    // Compute average green channel in boxed ROI (center region)
    try{
      const rx = Math.floor(scratch.width*0.4);
      const ry = Math.floor(scratch.height*0.25);
      const rw = Math.floor(scratch.width*0.2);
      const rh = Math.floor(scratch.height*0.25);
      const imageData = sctx.getImageData(rx, ry, rw, rh);
      let sumG = 0;
      const data = imageData.data;
      for(let i=1;i<data.length;i+=4) sumG += data[i]; // green channel
      const avgG = sumG / (data.length/4);
      // push to samples (normalized)
      samples.push(avgG);
      if(samples.length > maxSamples) samples.shift();
    } catch(e){
      // ignore read errors
    }

    requestAnimationFrame(processFrame);
  }

  processFrame();

  return {
    getSamples: () => samples
  };
}

/* ---------- Chart update loop ---------- */
function pushToChart(chartObj, value){
  const maxPoints = 200;
  const data = chartObj.data.datasets[0].data;
  const labels = chartObj.data.labels;
  const ts = new Date().toLocaleTimeString();
  labels.push(ts);
  data.push(value);
  if(data.length > maxPoints){ data.shift(); labels.shift(); }
  chartObj.update('none');
}

function updateChartsFromSamples(samples, chart, spo2El, ppgEl){
  if(!samples || samples.length===0) return;
  // crude AC estimation: bandpass-ish effect by subtracting moving average
  const arr = samples.slice(-120);
  const mean = arr.reduce((a,b)=>a+b,0)/arr.length;
  const ac = arr[arr.length-1] - mean;
  // scale to human-friendly range: map avg to pseudo-PPG (30-120)
  const pseudo = 75 + (ac * 2.5);
  const spo2Pseudo = 95 + Math.sin(Date.now()/5000) * 2; // demo spo2 wobble
  pushToChart(chart, pseudo);
  if(spo2El) spo2El.textContent = spo2Pseudo.toFixed(1);
  if(ppgEl) ppgEl.textContent = Math.round(pseudo);
}

/* ---------- Initialize frame processors for both cameras ---------- */
let frontGrabber, rearGrabber;

function startProcessors(){
  const frontVideo = document.getElementById('frontCam');
  const rearVideo = document.getElementById('rearCam');
  frontGrabber = createFrameGrabber(frontVideo, 'frontOverlay');
  rearGrabber = createFrameGrabber(rearVideo, 'rearOverlay');

  // chart update interval
  setInterval(()=> {
    updateChartsFromSamples(frontGrabber.getSamples(), charts.ppgFront, document.getElementById('spo2Front'), document.getElementById('hrFront'));
    updateChartsFromSamples(rearGrabber.getSamples(), charts.ppgRear, document.getElementById('spo2Rear'), document.getElementById('hrRear'));
  }, 200); // 5Hz chart updates (changeable)
}

/* ---------- Demo signals (fallback if cameras not available) ---------- */
function startDemoSignals(){
  // If no video input or user denies camera, feed demo sine waves into charts
  const t0 = Date.now();
  const demoInterval = setInterval(()=> {
    const t = (Date.now() - t0) / 1000;
    const frontVal = 75 + Math.sin(t*1.7) * 3 + Math.sin(t*0.25)*1.2;
    const rearVal  = 76 + Math.sin(t*1.65) * 2.8 + Math.sin(t*0.22)*1.1;
    pushToChart(charts.ppgFront, frontVal);
    pushToChart(charts.ppgRear, rearVal);
    // demo spo2 traces
    pushToChart(charts.spo2Front, 95 + Math.sin(t*0.2) );
    pushT
