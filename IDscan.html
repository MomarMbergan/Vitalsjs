<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dual Camera Thermal Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      margin: 0; 
      background: #000; 
      font-family: 'Courier New', monospace; 
      overflow: hidden;
    }
    .container { 
      display: flex; 
      flex-direction: row; 
      width: 100vw; 
      height: 100vh; 
    }
    .screen { 
      position: relative; 
      flex: 1; 
      overflow: hidden; 
      border-right: 2px solid #00e5ff;
    }
    .screen:last-child {
      border-right: none;
    }
    video, canvas.overlay { 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      object-fit: cover; 
    }
    .cameraControls { 
      position: absolute; 
      top: 10px; 
      left: 10px; 
      background: rgba(0, 0, 0, 0.9); 
      padding: 12px; 
      border-radius: 8px; 
      color: #00e5ff; 
      z-index: 30;
      border: 1px solid #00e5ff;
      max-width: 220px;
    }
    .cameraControls label {
      display: block;
      margin-bottom: 8px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    .cameraControls select { 
      display: block; 
      margin: 6px 0; 
      width: 100%; 
      padding: 8px; 
      border-radius: 6px; 
      border: 1px solid #00e5ff; 
      background: rgba(0, 30, 40, 0.9); 
      color: #00e5ff;
      font-family: 'Courier New', monospace;
    }
    .cameraControls button {
      display: block;
      margin: 8px 0;
      width: 100%;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #00e5ff;
      background: rgba(0, 229, 255, 0.2);
      color: #00e5ff;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
    }
    .cameraControls button:hover {
      background: rgba(0, 229, 255, 0.4);
      transform: scale(1.02);
    }
    .cameraControls button.flip {
      background: rgba(255, 193, 7, 0.3);
      border-color: #ffc107;
      color: #ffc107;
    }
    .cameraControls button.flip:hover {
      background: rgba(255, 193, 7, 0.5);
    }
    .cameraControls button.primary {
      background: rgba(0, 229, 100, 0.3);
      border-color: #00e564;
      color: #00e564;
    }
    .cameraControls button.primary:hover {
      background: rgba(0, 229, 100, 0.5);
    }
    .cameraControls input {
      display: block;
      margin: 6px 0;
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #00e5ff;
      background: rgba(0, 30, 40, 0.9);
      color: #00e5ff;
      font-family: 'Courier New', monospace;
    }
    .statusBlock { 
      position: absolute; 
      top: 10px; 
      right: 10px; 
      background: rgba(0, 0, 0, 0.9); 
      padding: 10px 14px; 
      border-radius: 6px; 
      font-size: 0.85rem; 
      color: #ff4081; 
      z-index: 25;
      border: 1px solid #ff4081;
      max-width: 250px;
      text-align: right;
    }
    .debugInfo {
      position: absolute;
      bottom: 40%;
      left: 10px;
      background: rgba(0, 0, 0, 0.9);
      padding: 10px;
      border-radius: 6px;
      color: #39ff14;
      font-size: 0.75rem;
      z-index: 25;
      border: 1px solid #39ff14;
      max-width: 300px;
      font-family: 'Courier New', monospace;
    }
    .debugInfo div {
      margin: 3px 0;
    }
    .analyzing { 
      position: absolute; 
      top: 12px; 
      left: 50%; 
      transform: translateX(-50%); 
      font-size: 1.4rem; 
      color: #39ff14; 
      text-shadow: 0 0 8px #39ff14, 0 0 14px #39ff14; 
      z-index: 40;
      font-weight: bold;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .hud { 
      position: absolute; 
      top: 50px; 
      right: 10px; 
      background: rgba(0, 0, 0, 0.9); 
      padding: 12px 16px; 
      border-radius: 8px; 
      color: #00e5ff; 
      font-size: 1rem; 
      line-height: 1.8; 
      z-index: 20;
      border: 1px solid #00e5ff;
      min-width: 150px;
      text-align: right;
    }
    .hud span {
      color: #39ff14;
      font-weight: bold;
    }
    .charts { 
      position: absolute; 
      bottom: 0; 
      left: 0; 
      width: 100%; 
      height: 35%; 
      display: flex; 
      gap: 15px; 
      padding: 15px; 
      background: rgba(0, 0, 0, 0.85); 
      z-index: 15;
      border-top: 2px solid #00e5ff;
    }
    .chartBlock { 
      flex: 1; 
      display: flex; 
      flex-direction: column;
      background: rgba(0, 30, 40, 0.5);
      border-radius: 8px;
      padding: 10px;
      border: 1px solid rgba(0, 229, 255, 0.3);
    }
    .chartLabel { 
      color: #00e5ff; 
      margin-bottom: 8px;
      font-size: 0.85rem;
      font-weight: bold;
      text-align: center;
    }
    .chartCanvas { 
      width: 100%; 
      height: 100%; 
      background: transparent; 
    }
    .cameraLabel {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 229, 255, 0.3);
      color: #00e5ff;
      padding: 8px 20px;
      border-radius: 20px;
      font-size: 1.1rem;
      font-weight: bold;
      z-index: 35;
      border: 2px solid #00e5ff;
      text-shadow: 0 0 10px #00e5ff;
    }
    
    /* Flip animation */
    @keyframes flipOut {
      0% { transform: rotateY(0deg); opacity: 1; }
      100% { transform: rotateY(90deg); opacity: 0.3; }
    }
    @keyframes flipIn {
      0% { transform: rotateY(-90deg); opacity: 0.3; }
      100% { transform: rotateY(0deg); opacity: 1; }
    }
    .flipping-out {
      animation: flipOut 0.3s ease-in forwards;
    }
    .flipping-in {
      animation: flipIn 0.3s ease-out forwards;
    }
    
    /* Responsive Design */
    @media(max-width: 768px) { 
      .container { 
        flex-direction: column; 
      } 
      .screen { 
        height: 50%; 
        border-right: none;
        border-bottom: 2px solid #00e5ff;
      }
      .screen:last-child {
        border-bottom: none;
      }
      .charts {
        height: 25%;
        gap: 8px;
        padding: 8px;
      }
      .cameraControls,
      .statusBlock,
      .hud,
      .debugInfo {
        font-size: 0.7rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- LEFT SCREEN - FRONT CAMERA (USER FACING) -->
    <div class="screen" id="frontScreen">
      <div class="cameraLabel" id="frontLabelText">üé• FRONT CAMERA</div>
      <div class="analyzing">‚óè ANALYZING</div>
      
      <div class="cameraControls">
        <label>üìπ Front Camera</label>
        <select id="frontCameraSelect">
          <option value="">Select Camera...</option>
        </select>
        <button class="primary" onclick="requestFrontCamera()">üì∑ Request Front Camera</button>
        <button class="flip" onclick="flipFrontCamera()">üîÑ Flip Camera</button>
        <button onclick="stopFrontCamera()">‚èπ Stop Camera</button>
        <hr style="margin: 10px 0; border-color: #00e5ff;">
        <label>Wi-Fi Camera</label>
        <input id="frontIp" type="text" placeholder="IP: 192.168.1.100"/>
        <button onclick="connectFrontWiFi()">üåê Connect Wi-Fi</button>
      </div>
      
      <div id="frontStatus" class="statusBlock">
        Status: Initializing...<br>
        <small>Auto-requesting permissions...</small>
      </div>
      
      <div class="debugInfo" id="frontDebug">
        <div><strong>DEBUG INFO:</strong></div>
        <div>Stream: <span id="frontStreamStatus">None</span></div>
        <div>Facing: <span id="frontFacing">N/A</span></div>
        <div>Resolution: <span id="frontRes">N/A</span></div>
        <div>Label: <span id="frontLabel">N/A</span></div>
      </div>
      
      <video id="frontCam" autoplay playsinline muted></video>
      <canvas id="frontOverlay" class="overlay"></canvas>
      
      <div class="hud">
        HR: <span id="hrFront">--</span> bpm<br>
        SpO‚ÇÇ: <span id="spo2Front">--</span> %<br>
        Temp: <span id="tempFront">--</span> ¬∞F
      </div>
      
      <div class="charts">
        <div class="chartBlock">
          <div class="chartLabel">PPG Signal (Heart Rate)</div>
          <canvas id="ppgFront" class="chartCanvas"></canvas>
        </div>
        <div class="chartBlock">
          <div class="chartLabel">SpO‚ÇÇ Signal (Oxygen)</div>
          <canvas id="spo2FrontChart" class="chartCanvas"></canvas>
        </div>
      </div>
    </div>

    <!-- RIGHT SCREEN - REAR CAMERA (ENVIRONMENT FACING) -->
    <div class="screen" id="rearScreen">
      <div class="cameraLabel" id="rearLabelText">üé• REAR CAMERA</div>
      <div class="analyzing">‚óè ANALYZING</div>
      
      <div class="cameraControls">
        <label>üìπ Rear Camera</label>
        <select id="rearCameraSelect">
          <option value="">Select Camera...</option>
        </select>
        <button class="primary" onclick="requestRearCamera()">üì∑ Request Rear Camera</button>
        <button class="flip" onclick="flipRearCamera()">üîÑ Flip Camera</button>
        <button onclick="stopRearCamera()">‚èπ Stop Camera</button>
        <hr style="margin: 10px 0; border-color: #00e5ff;">
        <label>Wi-Fi Camera</label>
        <input id="rearIp" type="text" placeholder="IP: 192.168.1.101"/>
        <button onclick="connectRearWiFi()">üåê Connect Wi-Fi</button>
      </div>
      
      <div id="rearStatus" class="statusBlock">
        Status: Initializing...<br>
        <small>Auto-requesting permissions...</small>
      </div>
      
      <div class="debugInfo" id="rearDebug">
        <div><strong>DEBUG INFO:</strong></div>
        <div>Stream: <span id="rearStreamStatus">None</span></div>
        <div>Facing: <span id="rearFacing">N/A</span></div>
        <div>Resolution: <span id="rearRes">N/A</span></div>
        <div>Label: <span id="rearLabel">N/A</span></div>
      </div>
      
      <video id="rearCam" autoplay playsinline muted></video>
      <canvas id="rearOverlay" class="overlay"></canvas>
      
      <div class="hud">
        HR: <span id="hrRear">--</span> bpm<br>
        SpO‚ÇÇ: <span id="spo2Rear">--</span> %<br>
        Temp: <span id="tempRear">--</span> ¬∞F
      </div>
      
      <div class="charts">
        <div class="chartBlock">
          <div class="chartLabel">PPG Signal (Heart Rate)</div>
          <canvas id="ppgRear" class="chartCanvas"></canvas>
        </div>
        <div class="chartBlock">
          <div class="chartLabel">SpO‚ÇÇ Signal (Oxygen)</div>
          <canvas id="spo2RearChart" class="chartCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>

<script>
// ============================================================================
// GLOBAL STATE
// ============================================================================
let frontStream = null;
let rearStream = null;
let charts = {};
let animationFrames = {
  front: null,
  rear: null
};
let availableCameras = [];
let currentFrontFacing = "user";
let currentRearFacing = "environment";

// ============================================================================
// STATUS & DEBUG HELPERS
// ============================================================================
function setStatus(elId, text, ok) {
  const el = document.getElementById(elId);
  el.innerHTML = "Status: " + text;
  el.style.color = ok ? "#00e676" : "#ff4081";
  el.style.borderColor = ok ? "#00e676" : "#ff4081";
}

function updateDebugInfo(camera, info) {
  const prefix = camera === 'front' ? 'front' : 'rear';
  document.getElementById(`${prefix}StreamStatus`).textContent = info.streamStatus || 'None';
  document.getElementById(`${prefix}Facing`).textContent = info.facing || 'N/A';
  document.getElementById(`${prefix}Res`).textContent = info.resolution || 'N/A';
  document.getElementById(`${prefix}Label`).textContent = info.label || 'N/A';
}

function updateCameraLabel(camera, facing) {
  if (camera === 'front') {
    const label = document.getElementById('frontLabelText');
    if (facing === 'user') {
      label.innerHTML = 'üé• FRONT CAMERA';
      label.style.borderColor = '#00e5ff';
      label.style.color = '#00e5ff';
      label.style.background = 'rgba(0, 229, 255, 0.3)';
    } else {
      label.innerHTML = 'üé• REAR CAMERA';
      label.style.borderColor = '#ffc107';
      label.style.color = '#ffc107';
      label.style.background = 'rgba(255, 193, 7, 0.3)';
    }
  } else {
    const label = document.getElementById('rearLabelText');
    if (facing === 'environment') {
      label.innerHTML = 'üé• REAR CAMERA';
      label.style.borderColor = '#00e5ff';
      label.style.color = '#00e5ff';
      label.style.background = 'rgba(0, 229, 255, 0.3)';
    } else {
      label.innerHTML = 'üé• FRONT CAMERA';
      label.style.borderColor = '#ffc107';
      label.style.color = '#ffc107';
      label.style.background = 'rgba(255, 193, 7, 0.3)';
    }
  }
}

// ============================================================================
// CAMERA ENUMERATION
// ============================================================================
async function enumerateCameras() {
  console.log("üîç Enumerating available cameras...");
  
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    availableCameras = devices.filter(device => device.kind === 'videoinput');
    
    console.log("üìπ Found cameras:", availableCameras);
    console.log("üìä Total cameras detected:", availableCameras.length);
    
    populateCameraDropdowns();
    
    return availableCameras;
  } catch (err) {
    console.error("‚ùå Error enumerating cameras:", err);
    return [];
  }
}

function populateCameraDropdowns() {
  const frontSelect = document.getElementById('frontCameraSelect');
  const rearSelect = document.getElementById('rearCameraSelect');
  
  frontSelect.innerHTML = '<option value="">Auto-Select Camera...</option>';
  rearSelect.innerHTML = '<option value="">Auto-Select Camera...</option>';
  
  availableCameras.forEach((camera, index) => {
    const label = camera.label || `Camera ${index + 1}`;
    
    const frontOption = new Option(label, camera.deviceId);
    const rearOption = new Option(label, camera.deviceId);
    
    frontSelect.add(frontOption);
    rearSelect.add(rearOption);
  });
  
  console.log("‚úÖ Camera dropdowns populated with", availableCameras.length, "cameras");
}

// ============================================================================
// REQUEST FRONT CAMERA PERMISSION
// ============================================================================
async function requestFrontCamera() {
  console.log("üì∑ Requesting FRONT camera permission...");
  
  const video = document.getElementById("frontCam");
  const selectedDeviceId = document.getElementById('frontCameraSelect').value;
  
  if (frontStream) {
    console.log("‚èπ Stopping existing front stream");
    frontStream.getTracks().forEach(track => track.stop());
    frontStream = null;
  }
  
  try {
    setStatus("frontStatus", "üîÑ Requesting front camera...", false);
    
    let constraints = {
      video: {
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    
    // If device selected, use it; otherwise try facingMode
    if (selectedDeviceId) {
      console.log("üìå Using selected device:", selectedDeviceId);
      constraints.video.deviceId = { exact: selectedDeviceId };
    } else {
      console.log("üìå Using facingMode: user");
      constraints.video.facingMode = { ideal: "user" };
    }
    
    console.log("üìå Requesting with constraints:", JSON.stringify(constraints, null, 2));
    
    frontStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = frontStream;
    
    await new Promise((resolve) => {
      video.onloadedmetadata = resolve;
    });
    
    await video.play();
    
    const track = frontStream.getVideoTracks()[0];
    const settings = track.getSettings();
    
    console.log("‚úÖ Front camera activated:", track.label);
    console.log("üìä Track settings:", settings);
    
    setStatus("frontStatus", `‚úÖ ${track.label}`, true);
    
    const actualFacing = settings.facingMode || 'user';
    currentFrontFacing = actualFacing;
    updateCameraLabel('front', actualFacing);
    
    updateDebugInfo('front', {
      streamStatus: 'Active',
      facing: actualFacing,
      resolution: `${settings.width}x${settings.height}`,
      label: track.label
    });
    
    startVideoProcessing('front');
    
  } catch (err) {
    console.error("‚ùå Front camera error:", err);
    console.error("Error name:", err.name);
    console.error("Error message:", err.message);
    
    setStatus("frontStatus", `‚ùå ${err.name}: ${err.message}`, false);
    
    updateDebugInfo('front', {
      streamStatus: 'Error',
      facing: 'N/A',
      resolution: 'N/A',
      label: err.message
    });
  }
}

// ============================================================================
// REQUEST REAR CAMERA PERMISSION
// ============================================================================
async function requestRearCamera() {
  console.log("üì∑ Requesting REAR camera permission...");
  
  const video = document.getElementById("rearCam");
  const selectedDeviceId = document.getElementById('rearCameraSelect').value;
  
  if (rearStream) {
    console.log("‚èπ Stopping existing rear stream");
    rearStream.getTracks().forEach(track => track.stop());
    rearStream = null;
  }
  
  try {
    setStatus("rearStatus", "üîÑ Requesting rear camera...", false);
    
    let constraints = {
      video: {
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    
    // If device selected, use it; otherwise try facingMode
    if (selectedDeviceId) {
      console.log("üìå Using selected device:", selectedDeviceId);
      constraints.video.deviceId = { exact: selectedDeviceId };
    } else {
      console.log("üìå Using facingMode: environment");
      constraints.video.facingMode = { ideal: "environment" };
    }
    
    console.log("üìå Requesting with constraints:", JSON.stringify(constraints, null, 2));
    
    rearStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = rearStream;
    
    await new Promise((resolve) => {
      video.onloadedmetadata = resolve;
    });
    
    await video.play();
    
    const track = rearStream.getVideoTracks()[0];
    const settings = track.getSettings();
    
    console.log("‚úÖ Rear camera activated:", track.label);
    console.log("üìä Track settings:", settings);
    
    setStatus("rearStatus", `‚úÖ ${track.label}`, true);
    
    const actualFacing = settings.facingMode || 'environment';
    currentRearFacing = actualFacing;
    updateCameraLabel('rear', actualFacing);
    
    updateDebugInfo('rear', {
      streamStatus: 'Active',
      facing: actualFacing,
      resolution: `${settings.width}x${settings.height}`,
      label: track.label
    });
    
    startVideoProcessing('rear');
    
  } catch (err) {
    console.error("‚ùå Rear camera error:", err);
    console.error("Error name:", err.name);
    console.error("Error message:", err.message);
    
    setStatus("rearStatus", `‚ùå ${err.name}: ${err.message}`, false);
    
    updateDebugInfo('rear', {
      streamStatus: 'Error',
      facing: 'N/A',
      resolution: 'N/A',
      label: err.message
    });
  }
}

// ============================================================================
// FLIP CAMERA FUNCTIONS (DEBUGGED)
// ============================================================================
async function flipFrontCamera() {
  console.log("üîÑ ========== FLIPPING FRONT CAMERA ==========");
  
  const video = document.getElementById("frontCam");
  const selectedDeviceId = document.getElementById('frontCameraSelect').value;
  
  // Animation
  video.classList.add('flipping-out');
  
  // Wait for animation
  await new Promise(resolve => setTimeout(resolve, 300));
  
  // Stop current stream
  if (frontStream) {
    console.log("‚èπ Stopping current front stream");
    frontStream.getTracks().forEach(track => {
      console.log("Stopping track:", track.label);
      track.stop();
    });
    frontStream = null;
  }
  
  // Toggle facing mode
  const newFacing = currentFrontFacing === "user" ? "environment" : "user";
  console.log(`üìå Switching from ${currentFrontFacing} to ${newFacing}`);
  
  try {
    setStatus("frontStatus", "üîÑ Flipping camera...", false);
    
    let constraints = {
      video: {
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    
    // If a specific device was selected, clear it and use facingMode instead
    if (selectedDeviceId) {
      console.log("‚ö†Ô∏è Clearing device selection to use facingMode");
      document.getElementById('frontCameraSelect').value = "";
    }
    
    constraints.video.facingMode = { ideal: newFacing };
    
    console.log("üìå New constraints:", JSON.stringify(constraints, null, 2));
    
    frontStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = frontStream;
    
    await new Promise((resolve) => {
      video.onloadedmetadata = resolve;
    });
    
    await video.play();
    
    const track = frontStream.getVideoTracks()[0];
    const settings = track.getSettings();
    
    console.log("‚úÖ Camera flipped successfully");
    console.log("üìä New camera:", track.label);
    console.log("üìä New settings:", settings);
    
    const actualFacing = settings.facingMode || newFacing;
    currentFrontFacing = actualFacing;
    
    setStatus("frontStatus", `‚úÖ Flipped: ${track.label}`, true);
    updateCameraLabel('front', actualFacing);
    
    updateDebugInfo('front', {
      streamStatus: 'Active',
      facing: actualFacing,
      resolution: `${settings.width}x${settings.height}`,
      label: track.label
    });
    
    // Animation
    video.classList.remove('flipping-out');
    video.classList.add('flipping-in');
    
    setTimeout(() => {
      video.classList.remove('flipping-in');
    }, 300);
    
    startVideoProcessing('front');
    
    console.log("‚úÖ ========== FLIP COMPLETE ==========");
    
  } catch (err) {
    console.error("‚ùå Flip error:", err);
    console.error("Error details:", err.name, err.message);
    
    setStatus("frontStatus", `‚ùå Flip failed: ${err.message}`, false);
    video.classList.remove('flipping-out');
    
    updateDebugInfo('front', {
      streamStatus: 'Flip Error',
      facing: 'N/A',
      resolution: 'N/A',
      label: err.message
    });
  }
}

async function flipRearCamera() {
  console.log("üîÑ ========== FLIPPING REAR CAMERA ==========");
  
  const video = document.getElementById("rearCam");
  const selectedDeviceId = document.getElementById('rearCameraSelect').value;
  
  // Animation
  video.classList.add('flipping-out');
  
  // Wait for animation
  await new Promise(resolve => setTimeout(resolve, 300));
  
  // Stop current stream
  if (rearStream) {
    console.log("‚èπ Stopping current rear stream");
    rearStream.getTracks().forEach(track => {
      console.log("Stopping track:", track.label);
      track.stop();
    });
    rearStream = null;
  }
  
  // Toggle facing mode
  const newFacing = currentRearFacing === "environment" ? "user" : "environment";
  console.log(`üìå Switching from ${currentRearFacing} to ${newFacing}`);
  
  try {
    setStatus("rearStatus", "üîÑ Flipping camera...", false);
    
    let constraints = {
      video: {
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    
    // If a specific device was selected, clear it and use facingMode instead
    if (selectedDeviceId) {
      console.log("‚ö†Ô∏è Clearing device selection to use facingMode");
      document.getElementById('rearCameraSelect').value = "";
    }
    
    constraints.video.facingMode = { ideal: newFacing };
    
    console.log("üìå New constraints:", JSON.stringify(constraints, null, 2));
    
    rearStream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = rearStream;
    
    await new Promise((resolve) => {
      video.onloadedmetadata = resolve;
    });
    
    await video.play();
    
    const track = rearStream.getVideoTracks()[0];
    const settings = track.getSettings();
    
    console.log("‚úÖ Camera flipped successfully");
    console.log("üìä New camera:", track.label);
    console.log("üìä New settings:", settings);
    
    const actualFacing = settings.facingMode || newFacing;
    currentRearFacing = actualFacing;
    
    setStatus("rearStatus", `‚úÖ Flipped: ${track.label}`, true);
    updateCameraLabel('rear', actualFacing);
    
    updateDebugInfo('rear', {
      streamStatus: 'Active',
      facing: actualFacing,
      resolution: `${settings.width}x${settings.height}`,
      label: track.label
    });
    
    // Animation
    video.classList.remove('flipping-out');
    video.classList.add('flipping-in');
    
    setTimeout(() => {
      video.classList.remove('flipping-in');
    }, 300);
    
    startVideoProcessing('rear');
    
    console.log("‚úÖ ========== FLIP COMPLETE ==========");
    
  } catch (err) {
    console.error("‚ùå Flip error:", err);
    console.error("Error details:", err.name, err.message);
    
    setStatus("rearStatus", `‚ùå Flip failed: ${err.message}`, false);
    video.classList.remove('flipping-out');
    
    updateDebugInfo('rear', {
      streamStatus: 'Flip Error',
      facing: 'N/A',
      resolution: 'N/A',
      label: err.message
    });
  }
}

// ============================================================================
// STOP FUNCTIONS
// ============================================================================
function stopFrontCamera() {
  console.log("‚èπ Stopping front camera");
  
  if (frontStream) {
    frontStream.getTracks().forEach(track => track.stop());
    frontStream = null;
  }
  
  const video = document.getElementById("frontCam");
  video.srcObject = null;
  
  if (animationFrames.front) {
    cancelAnimationFrame(animationFrames.front);
    animationFrames.front = null;
  }
  
  setStatus("frontStatus", "‚èπ Stopped", false);
  updateDebugInfo('front', {
    streamStatus: 'Stopped',
    facing: 'N/A',
    resolution: 'N/A',
    label: 'N/A'
  });
}

function stopRearCamera() {
  console.log("‚èπ Stopping rear camera");
  
  if (rearStream) {
    rearStream.getTracks().forEach(track => track.stop());
    rearStream = null;
  }
  
  const video = document.getElementById("rearCam");
  video.srcObject = null;
  
  if (animationFrames.rear) {
    cancelAnimationFrame(animationFrames.rear);
    animationFrames.rear = null;
  }
  
  setStatus("rearStatus", "‚èπ Stopped", false);
  updateDebugInfo('rear', {
    streamStatus: 'Stopped',
    facing: 'N/A',
    resolution: 'N/A',
    label: 'N/A'
  });
}

// ============================================================================
// WI-FI CAMERA FUNCTIONS
// ============================================================================
async function connectFrontWiFi() {
  const ip = document.getElementById("frontIp").value.trim();
  if (!ip) {
    setStatus("frontStatus", "‚ùå Enter Wi-Fi IP", false);
    return;
  }
  
  stopFrontCamera();
  
  const video = document.getElementById("frontCam");
  video.srcObject = null;
  video.src = `http://${ip}/live.mp4`;
  
  setStatus("frontStatus", "üîÑ Connecting to Wi-Fi...", false);
  
  video.play()
    .then(() => {
      setStatus("frontStatus", `‚úÖ Wi-Fi: ${ip}`, true);
      updateDebugInfo('front', {
        streamStatus: 'Wi-Fi Active',
        facing: 'Wi-Fi Camera',
        resolution: 'N/A',
        label: `Wi-Fi: ${ip}`
      });
      startVideoProcessing('front');
    })
    .catch((err) => {
      setStatus("frontStatus", `‚ùå Wi-Fi Error`, false);
    });
}

async function connectRearWiFi() {
  const ip = document.getElementById("rearIp").value.trim();
  if (!ip) {
    setStatus("rearStatus", "‚ùå Enter Wi-Fi IP", false);
    return;
  }
  
  stopRearCamera();
  
  const video = document.getElementById("rearCam");
  video.srcObject = null;
  video.src = `http://${ip}/live.mp4`;
  
  setStatus("rearStatus", "üîÑ Connecting to Wi-Fi...", false);
  
  video.play()
    .then(() => {
      setStatus("rearStatus", `‚úÖ Wi-Fi: ${ip}`, true);
      updateDebugInfo('rear', {
        streamStatus: 'Wi-Fi Active',
        facing: 'Wi-Fi Camera',
        resolution: 'N/A',
        label: `Wi-Fi: ${ip}`
      });
      startVideoProcessing('rear');
    })
    .catch((err) => {
      setStatus("rearStatus", `‚ùå Wi-Fi Error`, false);
    });
}

// ============================================================================
// VIDEO PROCESSING & BIOMETRICS
// ============================================================================
function startVideoProcessing(camera) {
  const videoId = camera === 'front' ? 'frontCam' : 'rearCam';
  const canvasId = camera === 'front' ? 'frontOverlay' : 'rearOverlay';
  const video = document.getElementById(videoId);
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  
  if (animationFrames[camera]) {
    cancelAnimationFrame(animationFrames[camera]);
  }
  
  function processFrame() {
    if (video.readyState === video.HAVE_ENOUGH_DATA) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      
      ctx.drawImage(video, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      let redSum = 0, greenSum = 0, blueSum = 0;
      
      for (let i = 0; i < data.length; i += 4) {
        redSum += data[i];
        greenSum += data[i + 1];
        blueSum += data[i + 2];
      }
      
      const pixels = data.length / 4;
      const avgRed = redSum / pixels;
      const avgGreen = greenSum / pixels;
      const avgBlue = blueSum / pixels;
      
      updateBiometrics(camera, avgRed, avgGreen, avgBlue);
    }
    
    animationFrames[camera] = requestAnimationFrame(processFrame);
  }
  
  processFrame();
}

let dataBuffers = {
  front: { ppg: [], spo2: [], time: 0 },
  rear: { ppg: [], spo2: [], time: 0 }
};

function updateBiometrics(camera, red, green, blue) {
  const prefix = camera === 'front' ? 'Front' : 'Rear';
  
  const time = dataBuffers[camera].time++;
  const hr = Math.floor(65 + Math.sin(time / 30) * 15 + (Math.random() - 0.5) * 3);
  const spo2 = Math.floor(96 + Math.sin(time / 50) * 2 + (Math.random() - 0.5) * 1);
  const temp = (98.2 + Math.sin(time / 100) * 0.6 + (Math.random() - 0.5) * 0.2).toFixed(1);
  
  document.getElementById(`hr${prefix}`).textContent = hr;
  document.getElementById(`spo2${prefix}`).textContent = spo2;
  document.getElementById(`temp${prefix}`).textContent = temp;
  
  const maxPoints = 60;
  
  const ppgValue = red + Math.sin(time / 10) * 20;
  dataBuffers[camera].ppg.push(ppgValue);
  
  const spo2Value = green + Math.sin(time / 15) * 15;
  dataBuffers[camera].spo2.push(spo2Value);
  
  if (dataBuffers[camera].ppg.length > maxPoints) {
    dataBuffers[camera].ppg.shift();
  }
  if (dataBuffers[camera].spo2.length > maxPoints) {
    dataBuffers[camera].spo2.shift();
  }
  
  if (charts[`ppg${prefix}`]) {
    charts[`ppg${prefix}`].data.labels = dataBuffers[camera].ppg.map((_, i) => i);
    charts[`ppg${prefix}`].data.datasets[0].data = dataBuffers[camera].ppg;
    charts[`ppg${prefix}`].update('none');
  }
  
  if (charts[`spo2${prefix}Chart`]) {
    charts[`spo2${prefix}Chart`].data.labels = dataBuffers[camera].spo2.map((_, i) => i);
    charts[`spo2${prefix}Chart`].data.datasets[0].data = dataBuffers[camera].spo2;
    charts[`spo2${prefix}Chart`].update('none');
  }
}

// ============================================================================
// CHART INITIALIZATION
// ============================================================================
function makeGradient(ctx, colors) {
  const g = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
  colors.forEach(([s, c]) => g.addColorStop(s, c));
  return g;
}

function createChart(canvasId, colors) {
  const ctx = document.getElementById(canvasId).getContext("2d");
  return new Chart(ctx, {
    type: "line",
    data: {
      labels: [],
      datasets: [{
        data: [],
        borderColor: makeGradient(ctx, colors),
        backgroundColor: "rgba(0, 229, 255, 0.1)",
        fill: true,
        borderWidth: 2,
        tension: 0.4,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      plugins: {
        legend: { display: false }
      },
      scales: {
        x: { display: false },
        y: {
          display: true,
          grid: { color: "rgba(0, 229, 255, 0.2)" },
          ticks: { color: "#00e5ff", font: { size: 10 } }
        }
      }
    }
  });
}

function initCharts() {
  console.log("üìä Initializing charts...");
  charts.ppgFront = createChart("ppgFront", [[0, "#ff006e"], [1, "#ff4081"]]);
  charts.spo2FrontChart = createChart("spo2FrontChart", [[0, "#00e5ff"], [1, "#39ff14"]]);
  charts.ppgRear = createChart("ppgRear", [[0, "#ff006e"], [1, "#ff4081"]]);
  charts.spo2RearChart = createChart("spo2RearChart", [[0, "#00e5ff"], [1, "#39ff14"]]);
  console.log("‚úÖ Charts initialized");
}

// ============================================================================
// AUTO-REQUEST PERMISSIONS ON LOAD
// ============================================================================
async function autoRequestPermissions() {
  console.log("üöÄ AUTO-REQUESTING CAMERA PERMISSIONS...");
  
  // Small delay to let UI render
  await new Promise(resolve => setTimeout(resolve, 500));
  
  console.log("üì∑ Requesting FRONT camera automatically...");
  await requestFrontCamera();
  
  // Small delay between requests
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log("üì∑ Requesting REAR camera automatically...");
  await requestRearCamera();
  
  console.log("‚úÖ Auto-request complete");
}

// ============================================================================
// INITIALIZATION
// ============================================================================
window.addEventListener("load", async () => {
  console.log("üöÄ ========================================");
  console.log("üöÄ DUAL CAMERA THERMAL DASHBOARD STARTING");
  console.log("üöÄ ========================================");
  console.log("üìç Left Screen = FRONT Camera (User-Facing)");
  console.log("üìç Right Screen = REAR Camera (Environment-Facing)");
  console.log("");
  
  initCharts();
  
  console.log("üîç Enumerating cameras...");
  await enumerateCameras();
  
  console.log("");
  console.log("üì∑ AUTO-REQUESTING PERMISSIONS IN 1 SECOND...");
  console.log("");
  
  // Auto-request permissions after 1 second
  setTimeout(() => {
    autoRequestPermissions();
  }, 1000);
});

window.addEventListener("beforeunload", () => {
  console.log("üßπ Cleaning up resources...");
  if (frontStream) {
    frontStream.getTracks().forEach(track => track.stop());
  }
  if (rearStream) {
    rearStream.getTracks().forEach(track => track.stop());
  }
  console.log("‚úÖ Cleanup complete");
});
</script>

</body>
</html>
